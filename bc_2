const SHA256 = require('crypto-js/sha256');
const BlockClass = require('./StarBlock.js');
const hex2ascii = require('hex2ascii');
const level = require('level');
const chainDB = './chaindata';
const chainDB2 = './chaindata2';
const crypto = require('crypto');
const EC = require('elliptic').ec;
const ec = new EC('secp256k1');
const db = level(chainDB, { createIfMissing: true }, function (err, db) {
    if (err instanceof level.errors.OpenError) {
        console.log('failed to open database')
    }
})

// Add data to levelDB with key/value pair
function addDataToLevelDB(key,value){

    return db.put(key, value);
}

// Get data from levelDB with key
function getDataFromLevelDB(key){
    var result = db.get(key);
    return result;
}
// Get Block Height
function getDBBlockHeight() {
    return new Promise((resolve, reject) => {
        let i = 0;
        db.createReadStream().on('data', (data) => {
            i++;
        }).on('error', (err) => {
            reject(err);
        }).on('close', () => {
            resolve(i);
        });
    });
}
let errorLog = [];
var num0fvalidblock=0;
var num0finvalidblock=0;
var invalidblockarray =[];
var validblockarray =[];
class Blockchain{
    constructor(isim){
        this.ad = isim;
        this.difficulty = 2;
        this.total_chain_height = -1;
        //if chain is empty
        this.addBlock(new BlockClass.StarBlock("GENESIS Block"));
    }

    // Get block height
    async getBlockHeight(){
        const chain_height = await getDBBlockHeight();
        return chain_height;
    }
    async bringBlockbyHash(blockHash){
        return await getDataFromLevelDBByHash(blockHash);
    }
    async bringBlockbyWalletAddress(address){
        return await getDataFromLevelDBByWalletAddress(address);
    }

    // get block
    async getBlock(blockHeight){
        const serializedBlock = await getDataFromLevelDB(blockHeight);
        return JSON.parse(serializedBlock)
    }
    // Add new block
    async addBlock(newBlock){
        //console.log("[" +this.ad+ "] before addBlock chain height: " +this.total_chain_height );
        //return newBlock.height;
        newBlock.height = this.total_chain_height + 1;
        if(newBlock.height>0){
            var prevBlock =  await this.getBlock(newBlock.height - 1);
            newBlock.previousBlockHash = prevBlock.hash;
        }
        newBlock.time = new Date().getTime();//.toString().slice(0,-3);
        //var hashHesaplanacakBody = JSON.stringify(newBlock);

        //newBlock.hash = SHA256(hashHesaplanacakBody).toString();
        newBlock.mineBlock(this.difficulty);
        this.total_chain_height++;
        //newBlock.recall_block = await hashModulo(newBlock.hash, this.total_chain_height);
        //var rn= (Math.floor(Math.random() * Number.MAX_SAFE_INTEGER))
        //var recall = Math.log10(rn);
        //newBlock.recall_block = rn % this.total_chain_height;
        //console.log("added block height: " + newBlock.height + " hash: " + newBlock.hash.toString() + " recall: " + newBlock.recall_block + " rand: "+rn +" crr tch: "+this.total_chain_height )

        // var tmp_recall_arr = []
        var recal_arr_size = Math.ceil(Math.log2(this.total_chain_height));

        //let initial_recall_data = {
        var recall_id= (Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)) % this.total_chain_height;
            //flag:false,

        newBlock.recall_arr.push(recall_id);
        recal_arr_size--;

        lbl: while (recal_arr_size > 0) {
            let recall_block_height =  (Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)) % this.total_chain_height;
            recall_block_height = this.total_chain_height - recall_block_height - 1;
            let flag = true;
            for (let i = 0; i < newBlock.recall_arr.length; i++) {
                if(recall_block_height === newBlock.recall_arr[i] ){
                    // continue lbl;
                    flag = false;
                }
            }

            if (!flag) {
                continue lbl;
            } else {
                //let recall_data = { recall_id: recall_block_height, //flag:false
                //};
                let recall_data = recall_block_height;
                newBlock.recall_arr.push(recall_data);
            }

            recal_arr_size--;
        }
        // newBlock.recall_arr = tmp_recall_arr;
        ////
        var iscurrentblockvalid = (Math.round(Math.random() * Number.MAX_SAFE_INTEGER)) % 3;

        if (iscurrentblockvalid)
        {
            newBlock.isvalid = true;
            validblockarray.push(newBlock);
            num0fvalidblock++;
        }
        else {
            newBlock.isvalid = false;
            invalidblockarray.push(newBlock);
            num0finvalidblock++
        }
        console.log("curr h: "+this.total_chain_height+" Logarithm size: " + newBlock.recall_arr.length + " recall_array: " + JSON.stringify(newBlock.recall_arr) + " isBlockvalid: "+ newBlock.isvalid )
        // console.log("added block height: " + newBlock.height + " hash: " + newBlock.hash.toString() + " recall_arr: " + JSON.stringify(newBlock.recall_arr) )
        await addDataToLevelDB(newBlock.height, JSON.stringify(newBlock));
        console.log("Block " + (newBlock.height)+" added to DB");
        return newBlock.height;
    }
    async validateBlock(blockHeight) {
        // get block object
        const block =  await this.getBlock(blockHeight);
        // get block hash
        let blockHash = block.hash;
        // remove block hash to test block integrity
        block.hash = "";
        var checkPoint= JSON .stringify(block);
        // generate block hash
        let currentBlockHash = SHA256(checkPoint).toString();
        //console.log('!!!blockHash= ' + blockHash +' & ' + 'validBlockHash= ' + validBlockHash);
        // Compare
        if (blockHash === currentBlockHash) {
            console.log('Block #' + blockHeight + ' validated'+ " Body : " + block.body);
            return true;
        } else {
            console.log('Block #' + blockHeight + ' has invalid hash '+ " Body : " + block.body);
            //console.log('blockHash= ' + blockHash +' & ' + 'validBlockHash= ' + validBlockHash);
            //console.log('???block '+ block.height + '  height: '+ block.height +'  Hash:'+ block.hash+ ' Time: ' +block.time + ' Body: '+checkPoint);
            throw "Block check error "+ blockHeight;
        }
    }
    /**validate chain functions****/

    async validateEachBlock(blockHeight) {

        for (let i = 0; i <= blockHeight; i++) {
            try {
                await this.validateBlock(i);
            } catch (err) {
                console.log('Error in validateBlockIntegrity ', err);
                errorLog.push(i);
            }
        }
        return errorLog;
    }

    async validateChainIntegrity(blockHeight) {
        //let errorLog = [];
        let currentBlock;
        let prevBlock;
        for (let i = 1; i <= blockHeight; i++) {

            currentBlock =  await this.getBlock(i);
            prevBlock =  await this.getBlock(i-1);
            if (currentBlock.previousBlockHash !== prevBlock.hash) {
                console.log("Previous Hash ERROR in validatechainIntegrity for Block " + i);
                errorLog.push(i);
            }
            else
                console.log("Hash is correct for Block " + i + " Body : " + currentBlock.body);
        }
        return errorLog;
    }

    async validateChain() {
        const blockHeight =  await this.getBlockHeight();

        let errorLog_1=[];
        errorLog_1=  await this.validateChainIntegrity(blockHeight-1);

        errorLog.concat(errorLog_1);

        //errorLog =  await this.validateEachBlock(blockHeight-1);
        errorLog.concat(errorLog_1);
        return errorLog;
    }
    async validateB() {
        const blockHeight =  await this.getBlockHeight();

        let errorLog_1=[];

        errorLog =  await this.validateEachBlock(blockHeight-1);
        errorLog.concat(errorLog_1);
        return errorLog;
    }
    async  guncelle(key){
        var blok = await bc.getBlock(key);
        blok.body = "Nevza"+key;
        await bc.updateBlock(key, blok);
    }
    async  guncelle2(key){
        var blok = await bc.getBlock(key);
        blok.previousBlockHash = "nevzatnevzatnevzat";
        await bc.updateBlock(key, blok);
    }
    async  updateBlock(key, blok){
        addDataToLevelDB(key, JSON.stringify(blok));
        console.log("Block " + (key)+" updated to DB");
        return key;
    }

}
let bc = new Blockchain();
const kayitEkle = (name) => bc.addBlock(new BlockClass.StarBlock(name))


const main = async ()=> {

    for (var i = 0; i < 100; i++) {
        const data1Result = await kayitEkle("Data"+(i+1));
    }
    console.log("numofvalidBlock: "+num0fvalidblock+ " numofinvalidBlock: "+ num0finvalidblock );
    //console.log(validblockarray);
    //console.log("valid_b_array:"+JSON.stringify(validblockarray));
    //console.log("invalid_b_array:"+JSON.stringify(invalidblockarray));
    //console.log("HEIGHT IS HERE: "+invalidblockarray[1].height)
    var k=0;
    var j= 0,y=0;
    var search_recall_id=0;
    for (var n=0;n < validblockarray.length; n++)
    {
        console.log("valid block no: " + validblockarray[n].height + " its recall arr:"+validblockarray[n].recall_arr);

    }
    while(j< validblockarray.length)
    {
        //console.log("no of the block j: "+j+" arr l: "+validblockarray[j].recall_arr.length)
        y=0
        while(k < validblockarray[j].recall_arr.length ) {

            while (y < invalidblockarray.length ) {
                console.log("i am at this block:"+j+ "and my recall arry l is: "+k);
                if (validblockarray[j].recall_arr[k] === invalidblockarray[y])
                {
                    console.log("Bu numaralı block:"+j+"bunu yakaladı"+ invalidblockarray[y])
                }
                y++;
            }
            y=0;
            k++;
        }
        k=0;
        j++;
    }
    /*await bc.guncelle2(8);
    const sonuc = await bc.getBlock(8);
    console.log(sonuc)
    let errlog = await bc.validateChain();
    if (errlog.length > 0) {
        console.log('Block errors = ' + errorLog.length);
        console.log('Blocks: ' + errlog);
    } else {
        console.log('No errors detected');
    }
    console.log("Chain analysis result " + errlog.toString());*/
    //
    /*let errlog2 = await bc.validateB();
    if (errlog2.length > 0) {
        console.log('Block errors = ' + errorLog.length);
        console.log('Blocks: ' + errlog2);
    } else {
        console.log('No errors detected22');
    }
    console.log("Chain analysis result2 " + errlog2.toString())*/
    //
}

main()
/*async function hashModulo(hash, operand) {
    hex_hash = "0x" + hash;
    console.log(hex_hash);
    return Number(BigInt(hash) % BigInt(operand));
}*/
module.exports.Blockchain = Blockchain;
